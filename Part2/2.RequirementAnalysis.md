![latest tag](https://img.shields.io/github/v/tag/gtuja/CSC_MS.svg?color=brightgreen)
[![Language](https://img.shields.io/badge/%E8%A8%80%E8%AA%9E-English-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/2.RequirementAnalysis_en.md)
[![Home](https://img.shields.io/badge/Home-Readme-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/README.md)
[![Part.2.1](https://img.shields.io/badge/Prev-Part.2.1-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/1.WorFlowOnGithub.md)
[![Part.2.3](https://img.shields.io/badge/Next-Part.2.3-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/3.SoftwareDesign.md)

# 2.2. 要求分析

<div id="toc"></div>
<details open>
<summary><font size="5"><b>Table of Contents</b></font></summary>

- [変更履歴](#history)
- [コンセプト](#Concept)
- [要求とは](#what_is_requirements)
- [Project XLM](#project_xlm)
- [Reference](#Reference)

</details>

<div id="history"></div>
<details open>
<summary><font size="5"><b>History</b></font></summary> 

- [TOC](#toc)
- v0.4 2024/09/24 Seho.Seo Brand new document.

</details>

<div id="Concept"></div>
<details open>
<summary><font size="5"><b>Concept</b></font></summary>

- [TOC](#toc)
- この章では、各々要求について議論します。
- 各要求を明確にし、簡単な製品XLM(X? Light Manager)を使って実習しましょう。 
- 言うまでもなく、ここで定義された要求がベストではありません。
- お互い議論しながら、いいものに仕上げていきましょう。
- [Golden ratio](https://en.m.wikipedia.org/wiki/Golden_ratio)と[Affordance](https://en.m.wikipedia.org/wiki/Affordance)を念頭に入れ、[Occam's razor](https://en.m.wikipedia.org/wiki/Occam%27s_razor)を手に持って切り開こう！

</details>

<div id="what_is_requirements"></div>
<details open>
<summary><font size="5"><b>要求とは</b></font></summary>

- [TOC](#toc)
- 要求に関する定義や方法論は数多くあります。
- ここでは、各要求を可能な限り単純に定義します。これが唯一のものではないことお忘れなく。
- SR(System Requirement)<br>
\- IEEE Guide for Developing System Requirements Specificationsに説明されているように、システム要求の目的は、**顧客ニーズの達成**です。<br>
\- **ニーズ**とは、**具体性がなくそのため曖昧**な傾向があります。<br>
- SyRS(System Requirement Specification)<br>
\- SyRSはSRに対して**実現可能性**が本質です。<br>
\- 定量的な観点に基づくことが多く、実装方法などの技術的な観点はあまり定義されません。<br>
\- ケースバイケースですが、基本的にSyRSは実装を制限してはいけないものです。<br>
- SwRS(Software Requirement Specification)<br>
\- SwRSはSyRSを満たすための**実現方法**を定義します。<br>
\- SwRSはSwDD(Software Detailed Design)と密接にリンクしていますが、多少抽象的な傾向はあります。<br>
- SwDD(Software Detailed Design)<br>
\- SwDDは**実装方法**を明確に記載します。<br>
\- SwRSを満たすためのコードレベルのガイドが含まれている場合があります。<br>
\- UMLなどの標準デザインパターンを使うのが有効的です。<br>
\- SwDDについては、[3.3.ソフトウェア設計](https://github.com/gtuja/CSC_MS/blob/main/Part2/3.SoftwareDesign.md)で詳しく見ていきましょう。
</details>

<div id="project_xlm"></div>
<details open>
<summary><font size="5"><b>Project XLM</b></font></summary>

- [TOC](#toc)
- これからは、簡単なプロジェクト一つを作り、XLM(X? Light Manager)、各々要求を考えてみましょう。<br>
- くどいですが、これがベストなわけありません。<br>
- SR<br>
\- [SR_01] システムはボタンの状態を取得します。<br>
\- [SR_02] システムはLEDの明るさを変更します。<br>
\- [SR_03] システムの応答時間は、1ミリ秒毎ににボタン状態とLED出力に応答する必要があります。<br>
\- [SR_04] システムはボタンのチャタリングを防止する必要があります。<br>
\- [SR_05] ボタンのチャタリング防止の一致数は5です。<br>
\- [SR_06] システムはボタンイベントを押された時間に応じて決定されます。押された時間が1秒未満の状態からボタンが放された場合は、短押しイベントを、押された時間が2秒に到達した場合は、即時に長押しイベントを通知します。<br>
\- [SR_07] システムはLEDのフェージング機能を提供する必要があります。<br>
\- [SR_08] LEDオフの状態でボタン短押しイベントが通知された場合は、フェードインを1秒間実施します。<br>
\- [SR_09] LEDオン状態でボタン短押しイベントが通知された場合は、フェードアウトを2秒間実施します。<br>
\- [SR_10] ボタン長押しイベントが通知されると、すぐにLED状態を切り替えます。<br>
\- [SR_11] システムは何らかのログ機能を提供する必要があります。<br>
  > どうでしょう？SRにしては細かすぎ？ですかね？<br>
  > とにかく進みましょう。

- SyRS<br>
\- [SyRS_01] **システム ブロック図**は以下です。[SR_01-SR_04]<br>
![システム ブロック図](https://github.com/gtuja/CSC_MS/blob/main/Resources/Part2/Part2_XLM_BlockDiagram.drawio.png)<br>
\- [SyRS_02] MCU(**STM32G0B1RE**)は、各ボタンとLEDを接続するために十分な10個を超える空きポートがあります。[SR_01、SR_02]<br> 
\- [SyRS_03] MCU(**STM32G0B1RE**)は最大64Mhzで駆動され、チャタリング防止、フェードイン、フェードアウトなどの機能を1ms毎に処理には余裕があります。[SR_03]<br>
\- [SyRS_04] OS機能(FreeRTOS など)を搭載しますので、定期的なプロセスとタスク処理が実装可能です。[SR_03、SR_10]<br>
\- [SyRS_05] ボタンとLED制御プロセスは、応答時間(1ms)を守るために、SysTickなどのTimer割り込みを用いた周期プロセスとして処理します。[SR_03]<br>
\- [SyRS_06] ボタ制御プロセスはボタン状態を取得し、[SR_04、SR_05] で定義されたチャタリング防止と、[SR_06]で定義されたボタンイベント(短押し、長押し)の抽出を実施します。[SR_01、SR_04、SR_05、SR_06]<br>
\- [SyRS_07] LED制御プロセスは、ボタンイベントの一貫性を確保するために、ボタンプロセスの後に処理されます。[SR_08、SR_09、SR_10]<br>
\- [SyRS_08] LED制御プロセスは、PWMタイマーを用いて [SR_07、SR_08、SR_09]で定義されたフェージング機能を提供します。[SR_07、SR_08、SR_09]<br>
\- [SyRS_09] ログ出力など、PCへの情報送信機能を提供する必要があります。[SR_10]<br>
- SwRS<br>
\- [SwRS_01] **ソフトウェア ブロック図**は下記です。[SyRS_01、SyRS_04]<br>
![ソフトウェア ブロック図](https://github.com/gtuja/CSC_MS/blob/main/Resources/Part2/Part2_XLM_BlockDiagram_Software.drawio.png)<br>
\- [SwRS_02] ソフトウェアはミドルウェア、HAL(Hardware Abstraction Layer)、FreeRTOSを使用します。[SyRS_04]<br>
\- [SwRS_03] アプリケーションサービスには、ボタンサービスとLEDサービスの2つがあります。<br>
\- [SwRS_04] アプリケーションサービスは、SysTickに割付ている専用タイマーの1msec毎のISR(Interrupt Service Routine)で実装されます。[SyRS_05]<br>
\- [SwRS_05] LED サービスは、ボタンイベントの一貫性を確保するために、ボタンサービスの後に処理されます。[SyRS_07]<br>
\- [SwRS_06] ボタンサービスは下記機能を提供します。<br>
&nbsp;&nbsp;\+ ボタン状態の取得 [SyRS_06]<br>
&nbsp;&nbsp;\+ チャタリング防止 [SyRS_06]<br>
&nbsp;&nbsp;\+ ボタンイベントを抽出 [SyRS_06]<br>
&nbsp;&nbsp;\+ ボタンの状態遷移を通知 [SyRS_09]<br>
\- [SwRS_07] ボタンサービスは、接続されたGPIOのボタン状態を取得します。[SyRS_06]<br>
\- [SwRS_08] ボタンサービスは下記の状態遷移によるチャタリング防止機能を実装します。[SyRS_06]<br>
![ボタンの状態図](https://github.com/gtuja/CSC_MS/blob/main/Resources/Part2/Part2_XLM_StateDiagram_Button.drawio.png)<br>
\- [SwRS_09] ボタンサービスは、[SyRS_06]で定義されたボタンイベントを抽出します。<br>
&nbsp;&nbsp;\+ ボタン短押し[SyRS_06]<br>
&nbsp;&nbsp;\+ ボタン長押し[SyRS_06]<br>
\- [SwRS_10] ボタンサービスはボタンタスクに状態遷移を通知します。[SyRS_09]。<br>
\- [SwRS_11] LEDサービスは下記機能を提供します。<br>
&nbsp;&nbsp;\+ LED出力 [SyRS_08]<br>
&nbsp;&nbsp;\+ フェーディング [SyRS_08]<br>
&nbsp;&nbsp;\+ LED状態遷移を通知 [SyRS_09]<br>
\- [SwRS_12] LEDサービスは、以下の状態遷移により、オン、オフ、フェーディングを実装します。[SyRS_08]<br>
![LED 状態図](https://github.com/gtuja/CSC_MS/blob/main/Resources/Part2/Part2_XLM_StateDiagram_LED.drawio.png)<br>
\- [SwRS_13] LEDサービスは状態遷移をボタンタスクに通知します。[SyRS_09]。<br>
\- [SwRS_14] アプリケーションタスクとして、ボタンタスク、LEDタスク、SWD(Serial Wire Debug)タスクの3つのタスクがあります。<br>
\- [SwRS_15] ボタンタスクは、IPC(Queueなど)を使用して、ボタンサービスからの状態遷移通知を受け付けます。[SyRS_09]<br>
\- [SwRS_16] ボタンタスクは、IPC(Queueなど)を使用して、SWDタスクに状態遷移を通知します。[SyRS_09]<br>
\- [SwRS_17] LEDタスクは、IPC(Queueなど)を使用して、LEDサービスからの状態遷移通知を受け付けます。[SyRS_09]<br>
\- [SwRS_18] LEDタスクは、IPC(Queueなど)を使用して、SWDタスクに状態遷移を通知します。[SyRS_09]<br>
\- [SwRS_19] SWDタスクは、IPC(Queueなど)を使用して、サービス及びタスクからの通知を受け付けます。[SyRS_09]<br>
\- [SwRS_20] SWDタスクは、UART通信でST-Linkにシリアルデータを送信し、ST-LinkはVirtual-Com通信で、外部(PCなど)へ送信します。[SyRS_09]<br>

</details>

<div id="Reference"></div>
<details open>
<summary><font size="5"><b>Reference</b></font></summary>

- [TOC](#toc)

</details>
<br>

![latest tag](https://img.shields.io/github/v/tag/gtuja/CSC_MS.svg?color=brightgreen)
[![Language](https://img.shields.io/badge/%E8%A8%80%E8%AA%9E-English-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/2.RequirementAnalysis_en.md)
[![Home](https://img.shields.io/badge/Home-Readme-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/README.md)
[![Part.2.1](https://img.shields.io/badge/Prev-Part.2.1-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/1.WorFlowOnGithub.md)
[![Part.2.3](https://img.shields.io/badge/Next-Part.2.3-brightgreen)](https://github.com/gtuja/CSC_MS/blob/main/Part2/3.SoftwareDesign.md)